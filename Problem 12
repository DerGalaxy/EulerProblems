import time
import math

"""
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
"""
#number of prime factors related to numbers of divisors
#d(n) = product of (1+m), m is the exponents of all prime factors
#example: 28 = 2^2 * 7^1, so d(28) = (2+1)*(1+1) = 6

def prime_factors(x):
    if x != 1:
        i=2
        while x % i != 0: #finds the lowest value factor, which must be prime
            i += 1
        return [i] + [prime_factors(x/i)] #now I make a list of all the primes
    else:
        return 0 #if x is 1, I've divided through all the factors - nothing more to do!
    
def nested_to_flat(array):
    if isinstance(array, list):
        for i in array:
            if isinstance(i, list):
                array.remove(i)
                array.extend(nested_to_flat(i))
        return array
    else:
        return array

def list_of_primes(x):
    primes = nested_to_flat(prime_factors(x))
            
    primes = [x for x in primes if x != 0]    
    
    exponents = {}
    for i in primes:
        if i not in exponents:
            exponents[i] = primes.count(i)
    
    return exponents

start = time.time()

counter = 2
not_found = False

while not not_found:
    triangle = (counter)*(counter + 1) / 2
    exponents = list_of_primes(triangle)
    
    divisors = 1
    for key in exponents:
        divisors *= (exponents[key]+1)
        
    counter+=1
    if divisors > 500:
        not_found = True

elapsed = (time.time() - start)
        
print("Number: {0:s}\nObtained in: {1:s}s".format(str(triangle),str(elapsed)))
